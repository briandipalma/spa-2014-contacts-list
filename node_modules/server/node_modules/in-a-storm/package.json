{
  "name": "in-a-storm",
  "version": "1.0.0",
  "description": "Find a port to run your server on.",
  "main": "index.js",
  "scripts": {
    "test": "mocha -R spec",
    "test-frameworks": "mocha -R spec ./test/frameworks"
  },
  "author": {
    "name": "me@kybernetikos.com"
  },
  "license": "BSD",
  "dependencies": {
    "bluebird": "~1.0.5"
  },
  "devDependencies": {
    "mocha": "~1.12.0",
    "restify": "~2.6.0",
    "express": "~3.3.5"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/kybernetikos/in-a-storm.git"
  },
  "keywords": [
    "port"
  ],
  "engines": {
    "node": ">=0.8.0"
  },
  "readme": "In A Storm\r\n==========\r\n\r\nFinds a port to bind your server to.  'In A Storm' is inspired by (and some code has been\r\ntaken from) [find-and-bind](https://github.com/gyllstromk/node-find-and-bind), but gives\r\nyou more ways of specifying what port(s) you want, and uses promises rather than node style\r\ncallbacks.\r\n\r\n    $ npm install in-a-storm\r\n\r\nUsage\r\n-----\r\n\r\n'In A Storm' provides a listen function that is designed to work with any server\r\nthat exposes the same interface as the node `net.Server` class.  It returns\r\na promise that will be fulfilled with the port number it is listening on.\r\n\r\n```js\r\n\r\nvar listen = require('in-a-storm');\r\n\r\nlisten(app).then(function(port) {\r\n\tconsole.log('Listening on port', port);\r\n});\r\n\r\n// or....\r\n\r\nlisten(app).then(function(port) {\r\n\tconsole.log('Listening on port', port);\r\n}).catch(function(err) {\r\n\tconsole.error('Something weird happened and I was unable to bind to any port at all : ' + err);\r\n});\r\n\r\n```\r\n\r\nIt will select an unused port, and bind your app to it.\r\n\r\nIf your app is an instance of http.Server, it will try the port in the environment variable PORT\r\nfirst, then it will try port 80, then it will try port 8080 before trying a port at random.\r\n\r\nIf your app is an instance of https.Server, it will try 443, then 8443 before a random port.\r\n\r\n### Specifying the ports to use\r\n\r\nThere are a number of ways to specify preferences for ports to use.\r\n\r\n\r\n```js\r\n\r\n// try port 8080, if that fails, select a random port.\r\nlisten(server, 8080);\r\nlisten(server, \"8080\");\r\n\r\n// try port 8080, then 8081, then 8082, then if that fails, select a random port.\r\nlisten(server, \"8080-8082\");\r\n\r\n// try port 80, then port 8080, then port 1000, then port 1001, then 1002, then a random port.\r\nlisten(server, [80, 8080, \"1000-1002\"]);\r\n\r\n// bind to a specific host address 'myhost' with backlog.\r\nlisten(server, [80, 8080, \"1000-1002\"], 'myhost', backlog);\r\n\r\n```\r\n\r\n### Compatible Servers\r\n\r\nAll servers that behave like net.Server will work.\r\n\r\nTo work correctly, the listen functions first argument must be the port to bind to and it must emit\r\na 'listening' event when the port is successfully bound.  It should also emit an error event if the\r\nport cannot be bound. If the port is set to 0, then a random available port must be chosen.  In\r\norder for in-a-storm to find out which port has been chosen, the server must provide a .address()\r\nmethod providing a result with the port on it.\r\n\r\nIf you call the listen function with a function instead of a server object, it is assumed that this\r\nis an http handler like an express app, and an http server is created for it.\r\n\r\nFuture Work\r\n-----------\r\n\r\nThe tests are mainly just modified versions of what find-and-bind does, so more work is needed\r\nthere.\r\n\r\nThere might well be other sensible default behaviours that can be added based on the\r\ninstance of the server.",
  "readmeFilename": "ReadMe.md",
  "bugs": {
    "url": "https://github.com/kybernetikos/in-a-storm/issues"
  },
  "homepage": "https://github.com/kybernetikos/in-a-storm",
  "_id": "in-a-storm@1.0.0",
  "_from": "in-a-storm@~1.0.0"
}
